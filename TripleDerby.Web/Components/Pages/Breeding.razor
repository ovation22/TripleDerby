@page "/breeding"
@rendermode InteractiveServer
@implements IDisposable
@using System.Linq
@using TripleDerby.SharedKernel
@using TripleDerby.SharedKernel.Enums
@using TripleDerby.SharedKernel.Pagination
@using TripleDerby.Web.ApiClients.Abstractions
@using TripleDerby.Web.Components.Ui;

@inject IBreedingApiClient BreedingApi
@inject IHorseApiClient HorseApi
@inject IUserApiClient UserApi

<PageTitle>Breeding</PageTitle>

<h1>Breeding</h1>

<FluentGrid>
    <FluentGridItem xs="12" sm="12" md="6">
        @if (_loadingDams)
        {
            <div>Loading dams...</div>
        }
        else if (!_dams.Any())
        {
            <div>No dams available.</div>
        }
        else
        {
            <h2>Dams</h2>
            <HorizontalCardSelector TItem="HorseResult"
                                    Items="@_dams.ToList()"
                                    SelectedIndex="@SelectedDamIndex"
                                    SelectedIndexChanged="i => SelectedDamIndex = i"
                                    SelectedItemChanged="OnDamChanged">
                <ItemTemplate Context="horse">
                    <FlipCard MinimalStyle="true" Height="250px" Width="300px">
                        <Front>
                            <div class="card-top">
                                <div class="card-image">
                                    <FluentEmoji Value="@(new Emojis.AnimalsNature.Color.Default.Horse())" />
                                </div>
                            </div>
                            <div class="card-bottom">
                                <div class="card-name">@horse.Name</div>
                                <div class="card-earnings">$@horse.Earnings</div>
                            </div>
                        </Front>
                        <Back>
                            <div class="card-stats">
                                <div class="card-title">Stats</div>
                                <div class="stat-row"><div class="stat-label">Starts</div><div class="stat-value">@horse.RaceStarts</div></div>
                                <div class="stat-row"><div class="stat-label">Wins</div><div class="stat-value">@horse.RaceWins</div></div>
                                <div class="stat-row"><div class="stat-label">Place</div><div class="stat-value">@horse.RacePlace</div></div>
                                <div class="stat-row"><div class="stat-label">Show</div><div class="stat-value">@horse.RaceShow</div></div>
                                <div class="stat-row"><div class="stat-label">Sire</div><div class="stat-value">@(horse.Sire ?? "-")</div></div>
                                <div class="stat-row"><div class="stat-label">Dam</div><div class="stat-value">@(horse.Dam ?? "-")</div></div>
                            </div>
                        </Back>
                    </FlipCard>
                </ItemTemplate>
            </HorizontalCardSelector>
        }
    </FluentGridItem>
    <FluentGridItem xs="12" sm="12" md="6">
    @if (_loadingSires)
    {
        <div>Loading sires...</div>
    }
    else if (!_sires.Any())
    {
        <div>No sires available.</div>
    }
    else
    {
        <h2>Sires</h2>
        <HorizontalCardSelector TItem="HorseResult"
                                Items="@_sires.ToList()"
                                SelectedIndex="@SelectedSireIndex"
                                SelectedIndexChanged="i => SelectedSireIndex = i"
                                SelectedItemChanged="OnSireChanged">
            <ItemTemplate Context="horse">
                <FlipCard MinimalStyle="true" Height="250px" Width="300px">
                    <Front>
                        <div class="card-top">
                            <div class="card-image">
                                <FluentEmoji Value="@(new Emojis.AnimalsNature.Color.Default.Horse())"/>
                            </div>
                        </div>
                        <div class="card-bottom">
                            <div class="card-name">@horse.Name</div>
                            <div class="card-earnings">$@horse.Earnings</div>
                        </div>
                    </Front>
                    <Back>
                        <div class="card-stats">
                            <div class="card-title">Stats</div>
                            <div class="stat-row">
                                <div class="stat-label">Starts</div>
                                <div class="stat-value">@horse.RaceStarts</div></div>
                            <div class="stat-row">
                                <div class="stat-label">Wins</div>
                                <div class="stat-value">@horse.RaceWins</div></div>
                            <div class="stat-row">
                                <div class="stat-label">Place</div>
                                <div class="stat-value">@horse.RacePlace</div></div>
                            <div class="stat-row">
                                <div class="stat-label">Show</div>
                                <div class="stat-value">@horse.RaceShow</div></div>
                            <div class="stat-row">
                                <div class="stat-label">Sire</div>
                                <div class="stat-value">@(horse.Sire ?? "-")</div></div>
                            <div class="stat-row">
                                <div class="stat-label">Dam</div>
                                <div class="stat-value">@(horse.Dam ?? "-")</div></div>
                        </div>
                    </Back>
                </FlipCard>
            </ItemTemplate>
        </HorizontalCardSelector>
    }
    </FluentGridItem>
</FluentGrid>

<div style="margin-top:1rem;">
    <label ><strong>Owner</strong></label>

    <FluentAutocomplete TOption="UserResult"
                        Width="320px"
                        Placeholder="Search users by username"
                        OptionText="@(u => $"{u.Username} ({u.Email})")"
                        Multiple="false"
                        OnOptionsSearch="OnOptionsSearchAsync"
                        @bind-SelectedOption="_selectedOwner" />
</div>

<div style="margin-top:1rem;">
    <FluentButton Appearance="Appearance.Accent"
                  Disabled="@(_selectedDamId == null || _selectedSireId == null || _selectedOwner == null || _isSubmitting || _hasBreedingStarted)"
                  @onclick="BreedAsync">
        @(_isSubmitting ? "Submitting..." : "Breed selected pair")
    </FluentButton>
</div>

@if (!string.IsNullOrEmpty(_errorMessage))
{
    <FluentMessageBar Style="margin-top: 2rem;"
                      Title="Error"
                      Intent="MessageIntent.Error"
                      @bind-Hidden="_hideError">
        @_errorMessage
    </FluentMessageBar>
}

@if (_isPolling)
{
    <div style="margin-top: 2rem;">
        <FluentProgressRing />
        <span style="margin-left: 1rem;">Status: @_currentStatus</span>
    </div>
}

@if (_breedResult is not null)
{
    <div style="margin-top:1rem;">
        <strong>Breed result:</strong> @_breedResult
    </div>
}

@code {
    IEnumerable<HorseResult> _dams = [];
    IEnumerable<HorseResult> _sires = [];

    bool _loadingDams = true;
    bool _loadingSires = true;

    Guid? _selectedDamId;
    Guid? _selectedSireId;

    private int SelectedSireIndex { get; set; }
    private void OnSireChanged(HorseResult? horse)
        => _selectedSireId = horse?.Id;

    private int SelectedDamIndex { get; set; }
    private void OnDamChanged(HorseResult? horse)
        => _selectedDamId = horse?.Id;

    string? _breedResult;

    // Autocomplete owner selection
    private UserResult? _selectedOwner;

    // Breeding state management
    private bool _hasBreedingStarted;
    private bool _isSubmitting;
    private bool _isPolling;
    private bool _breedingCompleted;
    private Guid? _currentRequestId;
    private string _currentStatus = "";
    private HorseResult? _foal;
    private string? _errorMessage;
    private bool _hideError = true;
    private CancellationTokenSource? _pollCts;

    protected override async Task OnInitializedAsync()
    {
        // Load dams and sires in parallel
        var damsTask = BreedingApi.GetDamsAsync();
        var siresTask = BreedingApi.GetSiresAsync();

        var damsResp = await damsTask;
        var siresResp = await siresTask;

        // Ensure deterministic sorting (case-insensitive by Name)
        _dams = (damsResp ?? [])
            .OrderBy(h => h.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();

        _sires = (siresResp ?? [])
            .OrderBy(h => h.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();

        _selectedDamId = _dams.First().Id;
        _selectedSireId = _sires.First().Id;

        _loadingDams = false;
        _loadingSires = false;

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnOptionsSearchAsync(OptionsSearchEventArgs<UserResult> e)
    {
        // Called by the FluentAutocomplete when the user types. Use the UserApi to search.
        var q = e.Text.Trim();

        PaginationRequest request;
        if (string.IsNullOrWhiteSpace(q))
        {
            // Load first N users when there's no search text
            request = new PaginationRequest
            {
                Page = 1,
                Size = 20,
                SortBy = "Username",
                Direction = SharedKernel.Pagination.SortDirection.Asc
            };
        }
        else
        {
            request = new PaginationRequest
            {
                Page = 1,
                Size = 20,
                SortBy = "Username",
                Direction = SharedKernel.Pagination.SortDirection.Asc,
                Filters = new Dictionary<string, Filter>
                {
                    ["Username"] = new() { Operator = FilterOperator.Contains, Value = q }
                }
            };
        }

        var resp = await UserApi.FilterAsync(request);
        e.Items = resp?.Data ?? [];
    }

    private async Task BreedAsync()
    {
        // Validation
        if (_selectedDamId == null || _selectedSireId == null || _selectedOwner == null)
        {
            _errorMessage = "Please select a dam, sire, and owner.";
            _hideError = false;
            return;
        }

        // Clear previous state
        _foal = null;
        _errorMessage = null;
        _hideError = true;
        _breedingCompleted = false;
        _breedResult = null;

        _isSubmitting = true;
        _hasBreedingStarted = true;

        try
        {
            // Submit breeding request
            var result = await BreedingApi.SubmitBreedingAsync(
                _selectedSireId.Value,
                _selectedDamId.Value,
                _selectedOwner.Id);

            if (result == null)
            {
                _errorMessage = "Failed to submit breeding request.";
                _hideError = false;
                _hasBreedingStarted = false;
                return;
            }

            _currentRequestId = result.Id;
            _currentStatus = result.Status.ToString();

            // Start polling
            await StartPollingAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error submitting breeding request: {ex.Message}";
            _hideError = false;
            _hasBreedingStarted = false;
        }
        finally
        {
            _isSubmitting = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task StartPollingAsync()
    {
        if (_currentRequestId == null)
            return;

        _pollCts?.Cancel();
        _pollCts?.Dispose();
        _pollCts = new CancellationTokenSource();

        _isPolling = true;
        var attempts = 0;
        var maxAttempts = 10;

        try
        {
            while (attempts < maxAttempts && !_pollCts.Token.IsCancellationRequested)
            {
                await Task.Delay(1000, _pollCts.Token);

                var status = await BreedingApi.GetRequestStatusAsync(_currentRequestId.Value);

                if (status == null)
                {
                    _errorMessage = "Failed to get breeding status.";
                    _hideError = false;
                    break;
                }

                _currentStatus = status.Status.ToString();
                await InvokeAsync(StateHasChanged);

                if (status is { Status: BreedingRequestStatus.Completed, FoalId: not null })
                {
                    _isPolling = false;
                    await InvokeAsync(StateHasChanged);

                    // Fetch foal details (will be implemented in Phase 5)
                    // var foal = await HorseApi.GetByIdAsync(status.FoalId.Value);
                    // if (foal != null) _foal = foal;
                    break;
                }
                else if (status.Status == BreedingRequestStatus.Failed)
                {
                    _errorMessage = $"Breeding failed: {status.FailureReason ?? "Unknown error"}";
                    _hideError = false;
                    break;
                }

                attempts++;
            }

            if (attempts >= maxAttempts)
            {
                _errorMessage = "Breeding processing timed out.";
                _hideError = false;
            }
        }
        catch (TaskCanceledException)
        {
            // Polling cancelled, ignore
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error polling breeding status: {ex.Message}";
            _hideError = false;
        }
        finally
        {
            _isPolling = false;
            _breedingCompleted = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        _pollCts?.Cancel();
        _pollCts?.Dispose();
    }
}
